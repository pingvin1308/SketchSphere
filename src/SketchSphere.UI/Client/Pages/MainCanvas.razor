@page "/maincanvas"
@using Microsoft.AspNetCore.Components
@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions
@using SketchSphere.UI.Render

<PageTitle>MainCanvas</PageTitle>

<button onclick="@ClearAsync">Cleara</button>
<button @onclick="() => SelectToolAsync(Tool.Rectangle)">Rectangle</button>
<button @onclick="() => SelectToolAsync(Tool.Diamond)">Diamond</button>
<button @onclick="() => SelectToolAsync(Tool.Circle)">Circle</button>
<button @onclick="() => SelectToolAsync(Tool.Line)">Line</button>
<button @onclick="() => SelectToolAsync(Tool.Draw)">Draw</button>

<div
    onmousemove="@OnMouseMoveAsync"
    onmousedown="@OnMouseDownAsync"
    onmouseup="@OnMouseUpAsync">
    <BECanvas
        Width="@_width"
        Height="@_height"
        @ref="_canvasReference">
    </BECanvas>
</div>

@code {
    private int _width = 500;
    private int _height = 500;

    private Canvas2DContext _context;
    private BECanvasComponent _canvasReference;

    private bool _isMouseDown;
    private bool _isDrawingStated;

    private List<DrawingObject> _drawingObjects = new();

    private DrawingObject? _currentDrawingObject;
    private Tool _currentTool;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _context = await _canvasReference.CreateCanvas2DAsync();

        if (firstRender)
        {
            await ClearCanvasAsync();
        }
    }

    private async Task OnMouseMoveAsync(MouseEventArgs e)
    {
        if (_isMouseDown)
        {
            var x = e.OffsetX;
            var y = e.OffsetY;

            if (!_isDrawingStated)
            {
                await _context.SetStrokeStyleAsync("#ffffff");
                await _context.SetLineWidthAsync(3);
                await _context.SetLineCapAsync(LineCap.Round);
                await _context.SetLineJoinAsync(LineJoin.Round);
                _isDrawingStated = true;
            }

            if (_currentDrawingObject != null)
            {
                Func<Task> initDrawingObjectAsync = _currentDrawingObject switch
                {
                    Circle circle =>  () => { return Task.CompletedTask; },
                    Diamond diamond =>  () => { return Task.CompletedTask; },
                    Freedraw freedraw => async () => { await freedraw.AddPointAsync(x, y); },
                    Line line => async () => { await line.SetEndAsync(x, y); },
                    Rectangle rectangle =>  () => { return Task.CompletedTask; },
                    _ => throw new ArgumentOutOfRangeException(nameof(_currentDrawingObject))
                };
                await initDrawingObjectAsync();
            }
        }

        await RenderAsync();
    }

    private async Task RenderAsync()
    {
        await ClearCanvasAsync();

        foreach (var drawingObject in _drawingObjects)
        {
            await drawingObject.DrawAsync(_context);
        }
    }

    private async Task OnMouseDownAsync(MouseEventArgs e)
    {
        Console.WriteLine($"Click - X: {e.OffsetX} Y: {e.OffsetY}");
        var x = e.OffsetX;
        var y = e.OffsetY;
        _isMouseDown = true;

        DrawingObject drawingObject = _currentTool switch
        {
            Tool.Rectangle => new Rectangle(x, y),
            Tool.Diamond => new Diamond(x, y),
            Tool.Circle => new Circle(x, y),
            Tool.Line => new Line(x, y),
            Tool.Draw => new Freedraw(x, y),
            _ => throw new ArgumentOutOfRangeException(nameof(_currentTool), _currentTool, null)
        };

        _currentDrawingObject = drawingObject;
        _drawingObjects.Add(drawingObject);
    }

    private async Task OnMouseUpAsync(MouseEventArgs e)
    {
        _isMouseDown = false;
        _isDrawingStated = false;
        _currentDrawingObject = null;
    }

    private async Task ClearCanvasAsync()
    {
        await _context.SetFillStyleAsync("#1e1e1e");
        await _context.FillRectAsync(0, 0, _width, _height);
    }

    private async Task ClearAsync()
    {
        await ClearCanvasAsync();
        _drawingObjects.Clear();
    }

    private Task SelectToolAsync(Tool selectedTool)
    {
        Console.WriteLine($"Selected tool: {selectedTool}");
        _currentTool = selectedTool;
        return Task.CompletedTask;
    }

}